module Qsp.Defines

module Tools =
    open FParsec

    let removeEmptyLines () =
        Clipboard.getSet (fun str ->
            // let x = System.Text.RegularExpressions.Regex.Replace(str, "^\n", "", System.Text.RegularExpressions.RegexOptions.Multiline)
            // x
            let ws = manySatisfy (fun c -> System.Char.IsWhiteSpace c && c <> '\n')
            let wsLine = ws .>>? skipNewline
            let p =
                spaces
                >>. many
                    (
                        ws >>. many1Satisfy ((<>) '\n')
                        .>> (skipNewline <|> eof)
                        .>> many wsLine
                    )
                |>> String.concat "\n"
            match run p str with
            | Success(x, _, _) -> x
            | Failure(x, _, _) -> failwithf "%A" x
        )
    // removeEmptyLines()
let notStringBinaryOperators =
    /// `[$выражение 1] & [$выражение 2]` - операция объединения строковых выражений.
    "&"
let proceduresWithAsterix =
    [
        /// `*CLEAR` или `*CLR` - очистка основного окна описаний.
        "*clear"
        /// `*CLEAR` или `*CLR` - очистка основного окна описаний.
        "*clr"
        /// `*NL [выражение]` - переход на новую строку, затем вывод текста в основном окне описаний. Если `[выражение]` не указано, то перевод строки. Отличается от *PL порядком вывода текста.
        "*nl"
        /// `*P [выражение]` - вывод текста в основное окно описаний (по умолчанию находится слева сверху и не может быть отключено).
        "*p"
        /// `*PL [выражение]` - вывод текста, затем переход на новую строку в основном окне описаний. Если `[выражение]` не указано, то перевод строки. Аналогичным образом можно вывести текст, просто написав нужное выражение вместо данного оператора. Например, строки:
        /// ```qsp
        /// *PL $AAA+'989'
        /// *PL 'Вы находитесь в парке'
        /// *PL 'Преформатированная
        /// строка'
        /// ```
        /// и
        /// ```qsp
        /// $AAA+'989'
        /// 'Вы находитесь в парке'
        /// 'Преформатированная
        /// строка'
        /// ```
        /// выполнят одно и то же действие.
        "*pl"
    ]

/// Заданные переменные строкового типа
let stringVars =
    [
        /// содержит путь к файлу изображения локации. Изображение локации показывается в том случае, если значение данной переменной отлично от '' (не пустая строка) и файл изображения удалось загрузить.
        "$backimage"
        /// содержит название локации-счётчика. Локация-счётчик полезна для проверки выделенных предметов, введённого текста...
        "$counter"
        /// текущие действия в виде текста. Сохранив значение в переменной, восстановить действия можно в любой момент игры с помощью оператора `DYNAMIC`.
        "$curacts"
        /// текст, находящийся в основном окне описаний. Также есть функция `maintxt`
        "$maintxt"
        /// содержит название используемого в данный момент шрифта. Если равна '' (пустая строка), то используется шрифт, заданный в настройках программы.
        "$fname"
        /// содержит название локации-обработчика выбора действия. Данная локация полезна, к примеру, для вывода изображений или проигрывания звуков при выборе действий. Получить название выбранного действия можно через функцию `SELACT`.
        "$onactsel"
        /// содержит название локации-обработчика загрузки состояния. Данная локация полезна для выполнения каких-либо действий после загрузки состояния игры.
        "$ongload"
        /// содержит название локации-обработчика сохранения состояния. Данная локация полезна для выполнения каких-либо действий перед сохранением состояния игры.
        "$ongsave"
        /// содержит название локации-обработчика перехода на новую локацию (аналог локации "common" в URQ). Может заменить часть функций локации-счётчика. Получить название локации, на которую был осуществлён переход, можно с помощью функции `CURLOC`.
        "$onnewloc"
        /// содержит название локации-обработчика добавления предмета. При добавлении предмета локация вызывается с аргументом `$ARGS[0]` - названием добавленного предмета. Данная локация полезна, к примеру, для ограничения вместительности рюкзака.
        "$onobjadd"
        /// содержит название локации-обработчика удаления предмета. При удалении предмета локация вызывается с аргументом `$ARGS[0]` - названием удалённого предмета. Данная локация полезна, к примеру, для проверки возможности удаления предмета.
        "$onobjdel"
        /// содержит название локации-обработчика выбора предмета. Данная локация полезна, к примеру, для вывода меню предметов. Получить название выбранного предмета можно через функцию `SELOBJ`.
        "$onobjsel"
        /// текст, находящийся в окне пользователя. Также есть функция `stattxt`
        "$stattxt"
        /// содержит название локации-обработчика строки ввода. Полезна при организации парсера (управление игрой с помощью строки ввода). Текущий текст строки ввода возвращает функция `USER_TEXT`.
        "$usercom"
        /// название текущей локации, также можно использовать `curloc`
        "$curloc"

    ]
let vars =
    [
        /// содержит размер используемого в данный момент шрифта. Если равна 0, то используется размер, заданный в настройках программы. Относительно данного значения в HTML-режиме вычисляются размеры шрифтов тега "FONT".
        "fsize"
        /// содержит цвет текущего фона. Если равна 0, то используется цвет, заданный в настройках программы.
        "bcolor"
        /// содержит цвет используемого в данный момент шрифта. Если равна 0, то используется цвет, заданный в настройках программы.
        "fcolor"
        /// содержит текущий цвет ссылок. Если равна 0, то используется цвет, заданный в настройках программы.
        "lcolor"
        /// если отлична от 0, включает возможность использования HTML в описании локации, в дополнительном описании, в списках действий и предметов, а также в диалоге ввода текста, вызываемого функцией `INPUT`. Выводимый текст распознаётся как HTML. Список поддерживаемых тегов и их атрибутов смотрите в приложении.
        "usehtml"
        /// ?
        "args"
        /// если значение переменной не равно 0, то отключается проверка идентификатора игры при загрузке состояния. Полезно для отладки.
        "debug"
        /// если значение переменной не равно 0, то запрещает автопрокрутку текста при его выводе в основное или дополнительное окно описания локации.
        "disablescroll"
        /// если значение переменной не равно 0, то запрещает использование "подвыражений" в тексте (например, значением `'<<5+6>>'` будет строка `'<<5+6>>'`, а не `'11'`).
        "disablesubex"
        /// Если её значение отлично от 0, то сохранение состояния игры пользователем невозможно.
        "nosave"
    ]
let functions =
    [
        /// `RAND([#выражение 1],[#выражение 2])` - возвращает случайное число между числами [#выражение 1] и [#выражение 2]. Параметр [#выражение 2] может отсутствовать, при этом он принимается равным 0.
        "rand"
        /// возвращает название текущей локации, также можно использовать переменную `$curloc`
        "curloc"
        /// возвращает случайное значение от 1 до 1000.
        "rnd"
        /// `INPUT([$выражение])` - выводит окно ввода с приглашением [$выражение]. Возвращает введённый играющим текст, либо '' (пустая строка), если была нажата кнопка "Отмена".
        "input"
        /// возвращает текст, находящийся в строке ввода. Синоним `usrtxt`
        "user_text"
        /// возвращает текст, находящийся в строке ввода. Синоним `user_text`
        "usrtxt"
        /// `MAX([выражение 1],[выражение 2], ...)` - возвращает максимальное из значений выражений-аргументов. Если передан один аргумент, то считается, что указано имя массива - в этом случае поиск максимального элемента происходит среди строковых (если название массива указано со знаком "$") или среди числовых значений элементов массива. Например:
        /// ```qsp
        /// MAX(1,2,5,2,0) & ! вернёт 5
        /// MAX(a,b,c) & ! вернёт максимальное из значений переменных
        /// MAX('aa','ab','zz') & ! вернёт 'zz'
        /// MAX('a') & ! вернёт максимальное из числовых значений элементов массива "A"
        /// MAX('$b') & ! вернёт максимальное из строковых значений элементов массива "B"
        /// ```
        "max"
        /// `MIN([выражение 1],[выражение 2], ...)` - возвращает минимальное из значений выражений-аргументов. Если передан один аргумент, то считается, что указано имя массива - в этом случае поиск минимального элемента происходит среди строковых (если название массива указано со знаком "$") или среди числовых значений элементов массива.
        "min"
        /// `IIF([#выражение],[выражение_да],[выражение_нет])` - возвращает значение выражения [выражение_да], если [#выражение] верно, иначе значение выражения [выражение_нет].
        "iif"
        /// `RGB([#выражение 1],[#выражение 2],[#выражение 3])` - возвращает код цвета на основе 3-х числовых аргументов. [#выражение 1], [#выражение 2] и [#выражение 3] определяют соответственно уровни красного, зелёного и синего цветов. Все значения аргументов должны быть в отрезке [0, 255]. Данная функция используется совместно с системными переменными `BCOLOR`, `FCOLOR` и `LCOLOR`.
        "rgb"
        /// `ISPLAY([$выражение])` - проверяет, проигрывается ли файл с заданным названием в текущий момент времени и возвращает -1, если файл воспроизводится, иначе 0.
        "isplay"
        /// возвращает количество миллисекунд, прошедших с момента начала игры.
        "msecscount"
        /// `DESC([$выражение])` - возвращает текст базового описания локации с заданным в [$выражение] названием.
        "desc"
        /// возвращает текст, находящийся в основном окне описаний. Также есть переменная `$maintxt`
        "maintxt"
        /// текст, находящийся в окне пользователя. Также есть переменная `$stattxt`
        "stattxt"
        /// возвращает версию интерпретатора в формате "X.Y.Z"
        "qspver"
        /// `FUNC([$выражение],[параметр 1],[параметр 2], ...)` - обработка локации с названием [$выражение]. Указанные параметры передаются в массиве `ARGS`. Результат функции равен значению `$RESULT` при возврате строкового значения или `RESULT` при возврате числового значения. Если при обработке локации были установлены и `RESULT`, и `$RESULT`, то предпочтение отдаётся строковому значению. После обработки локации предыдущие значения `ARGS` и `RESULT` восстанавливаются. Примеры:
        /// ```qsp
        /// PL 4 + FUNC('функция') & ! обработка локации "функция" как функции. Массив ARGS пуст. Результат передается через $RESULT или RESULT, в зависимости от кода обрабатываемой локации.
        /// PL FUNC($name, 1) * 78 & ! обработка локации с названием в $name как функции. ARGS[0] равен 1.
        /// MSG "text" + FUNC($name, "строка", 2) & ! обработка локации с названием в $name как функции. $ARGS[0] содержит строку "строка", ARGS[1] равен 2.
        /// ```
        "func"
        /// `DYNEVAL([$выражение],[параметр 1],[параметр 2], ...)` - возвращает значение указанного выражения. Функция позволяет вычислять значения динамически сгенерированных выражений. Указанные параметры передаются в массиве `ARGS`, а после вычисления выражения предыдущие значения `ARGS` восстанавливаются. Примеры:
        /// ```qsp
        /// DYNEVAL('3+4')
        /// PL DYNEVAL('mid("abcd",2,1)+"qwerty"')
        /// PL DYNEVAL($test + ' + val("<<$test>>")')
        /// проход=DYNEVAL(" $args[0] <> 'текст' ", 'строка')
        /// ```
        "dyneval"
        /// возвращает количество предметов в рюкзаке.
        "countobj"
        /// возвращает название выделенного предмета.
        "selobj"
        /// `GETOBJ([#выражение])` - возвращает название предмета в рюкзаке, расположенного в заданной позиции. Индексация предметов рюкзака ведётся с 1.
        /// Если предмета с заданным индексом не существует, возвращается пустая строка ('').
        ///
        /// Примеры:
        /// ```qsp
        /// GETOBJ(1) & ! вернёт название первого предмета в рюкзаке
        /// GETOBJ(COUNTOBJ) &! вернёт название последнего добавленного предмета
        /// ```
        ///
        /// Код, подсчитывающий в массиве `OBJECTS` число предметов с одинаковым названием:
        /// ```qsp
        /// i = 1
        /// :loop
        /// IF i <= COUNTOBJ:
        ///     OBJECTS[$GETOBJ(i)] = OBJECTS[$GETOBJ(i)] + 1
        ///     i = i + 1
        ///     JUMP 'loop'
        /// END
        /// ```
        "getobj"
        /// `ARRCOMP([#выражение 1],[$выражение 2],[$выражение 3])` - возвращает индекс элемента массива с названием `[$выражение 2]`, соответствующего регулярному выражению `[$выражение 3]`. Поиск начинается с элемента номер `[#выражение 1]`; индексация элементов массива ведётся с нуля. Параметр `[#выражение 1]` может отсутствовать, при этом он принимается равным 0. Если элемент не найден, функция возвращает -1.
        /// Поиск происходит среди текстовых элементов массива. Примеры:
        /// ```qsp
        /// ARRCOMP(0,'A','This') & ! найдёт строку 'This' среди текстовых элементов массива "A" (или вернёт -1, если такого значения не существует)
        /// ARRCOMP(2,'A','abc\d+') & ! найдёт строку, соответствующую регулярному выражению "abc\d+", в текстовых значениях массива "A" (первые два элемента массива игнорируются)
        /// ARRCOMP(0,'A','.*string.*') & ! аналогично предыдущему примеру, но поиск осуществляется по всем текстовым элементам массива
        /// ARRCOMP('A','This') & ! эквивалентно 1-му варианту
        /// ```
        "arrcomp"
        /// `STRCOMP([$выражение],[$шаблон])` - проводит сравнение строки [$выражение] на соответствие регулярному выражению `[$шаблон]`. Возвращает -1, если строка соответствует шаблону, иначе 0. Сравни с функцией `STRFIND`.
        "strcomp"
        /// `STRFIND([$выражение],[$шаблон],[#номер])` - возвращает подстроку в строке `[$выражение]`, соответствующую группе с номером `[#номер]` регулярного выражения `[$шаблон]`. Если подстрока с указанным номером отсутствует, то возвращается пустая строка. Нумерация групп подстрок начинается с 1. Если параметр `[#номер]` отсутствует или равен 0, то возвращается подстрока, соответствующая всему регулярному выражению `[$шаблон]`. Примеры:
        /// ```qsp
        /// STRFIND(' идти к пещере', '^(\S+)\s(\S+)\s(\S+)$', 0) & ! -> ''
        /// STRFIND('идти к пещере', '^(\S+)\s(\S+)\s(\S+)$', 1) & ! -> 'идти'
        /// STRFIND('идти к пещере', '^(\S+)\s(\S+)\s(\S+)$', 2) & ! -> 'к'
        /// STRFIND('идти к пещере', '^(\S+)\s(\S+)\s(\S+)$', 3) & ! -> 'пещере'
        /// STRFIND('идти к пещере', '^(\S+)\s(\S+)(\s(\S+))?$', 4) & ! -> 'пещере'
        /// STRFIND('искать ключ', '^(\S+)\s(\S+)(\s(\S+))?$', 1) & ! -> 'искать'
        /// STRFIND('искать', '^(\S+)\s(\S+)(\s(\S+))?$', 0) & ! -> ''
        /// STRFIND('искать', '^(\S+)\s(\S+)(\s(\S+))?$', 1) & ! -> ''
        /// STRFIND('искать', '^(\S+)(\s(\S+)(\s(\S+))?)?$', 1) & ! -> 'искать'
        /// STRFIND('идти к дому', 'к\s(\S+)', 0) & ! -> 'к дому'
        /// STRFIND('идти к дому', 'к\s(\S+)') & ! -> 'к дому'
        /// STRFIND('идти к дому', 'к\s(\S+)', 1) & ! -> 'дому'
        /// STRFIND('идти к своему дому', 'к\s(\S+)', 1) & ! -> 'своему'
        /// ```
        "strfind"
        /// `STRPOS([$выражение],[$шаблон],[#номер])` - возвращает позицию символа, с которого начинается вхождение подстроки в строке `[$выражение]`, соответствующей группе с номером `[#номер]` регулярного выражения `[$шаблон]`. Если подстрока с указанным номером отсутствует, то возвращается 0. Нумерация групп подстрок начинается с 1. Если параметр `[#номер]` отсутствует или равен 0, то возвращается позиция символа, с которого начинается вхождение подстроки, соответствующей всему регулярному выражению `[$шаблон]`.
        /// Примеры:
        /// ```qsp
        /// STRPOS(' идти к пещере', '^(\S+)\s(\S+)\s(\S+)$', 0) & ! -> 0
        /// STRPOS('идти к пещере', '^(\S+)\s(\S+)\s(\S+)$', 1) & ! -> 1
        /// STRPOS('идти к пещере', '^(\S+)\s(\S+)\s(\S+)$', 2) & ! -> 6
        /// STRPOS('идти к пещере', '^(\S+)\s(\S+)\s(\S+)$', 3) & ! -> 8
        /// STRPOS('идти к пещере', '^(\S+)\s(\S+)(\s(\S+))?$', 4) & ! -> 8
        /// STRPOS('искать ключ', '^(\S+)\s(\S+)(\s(\S+))?$', 1) & ! -> 1
        /// STRPOS('искать', '^(\S+)\s(\S+)(\s(\S+))?$', 0) & ! -> 0
        /// STRPOS('искать', '^(\S+)\s(\S+)(\s(\S+))?$', 1) & ! -> 0
        /// STRPOS('искать', '^(\S+)(\s(\S+)(\s(\S+))?)?$', 1) & ! -> 1
        /// STRPOS('идти к дому', 'к\s(\S+)', 0) & ! -> 6
        /// STRPOS('идти к дому', 'к\s(\S+)') & ! -> 6
        /// STRPOS('идти к дому', 'к\s(\S+)', 1) & ! -> 8
        /// STRPOS('идти к своему дому', 'к\s(\S+)', 1) & ! -> 8
        /// ```
        "strpos"
        /// возвращает текущие действия в виде текста. Сохранив значение в переменной, восстановить действия можно в любой момент игры с помощью оператора `DYNAMIC`.
        "curacts"
        /// `ARRPOS([#выражение 1],[$выражение 2],[выражение 3])` - возвращает индекс элемента массива с названием `[$выражение 2]`, равного значению выражения `[выражение 3]`. Поиск начинается с элемента номер `[#выражение 1]`; индексация элементов массива ведётся с нуля. Параметр [#выражение 1] может отсутствовать, при этом он принимается равным 0. Если указанное значение не найдено, функция возвращает -1.
        /// Чтобы найти числовое значение в массиве, нужно в `[$выражение 2]` подставить лишь название массива (в кавычках), для строкового - название массива с символом "$" перед его названием. Примеры:
        /// `ARRPOS(0,'$A','This')` - найдёт строку 'This' в текстовых значениях массива "A" (или вернёт -1, если такого значения не существует)
        /// `ARRPOS(2,'A',65)` - найдёт число 65 в числовых значениях массива "A" (при этом первые два элемента массива игнорируются)
        /// `ARRPOS('$B','test')` - поиск строки 'test' среди текстовых значений массива "B"
        "arrpos"
        /// `ARRSIZE([$выражение])` - возвращает число элементов в массиве с названием `[$выражение]`.
        "arrsize"
        /// `INSTR([#выражение 1],[$выражение 2],[$выражение 3])` - возвращает номер позиции символа, с которого начинается вхождение строки `[$выражение 3]` в строку `[$выражение 2]` (или 0, если такой строки нет). Поиск начинается с символа номер `[#выражение 1]`. Параметр `[#выражение 1]` может отсутствовать, при этом он принимается равным 1. Примеры:
        /// `INSTR(1,'ABCDefgh','BC')` равно `2`
        /// `INSTR(1,'ABCDefgh','Be')` равно `0`
        /// `INSTR('abcdef','abc')` равно `1`
        "instr"
        /// `ISNUM([$выражение])` - функция проверяет, все ли символы в строке являются цифрами (учитывая знак "-" в начале, прилегающие пробелы и символы табуляции). Если в указанной строке есть хотя бы один символ - не-цифра (исключая возможный "-" в начале и прилегающие пробелы / символы табуляции), то функция возвращает 0 (ложь), иначе -1 (истина).
        /// Функция полезна при проверке введённой играющим строки на число. Примеры:
        /// `ISNUM('9999 ')` равно `-1`
        /// `ISNUM(' -888')` равно `-1`
        /// `ISNUM('777a6')` равно `0`
        "isnum"
        /// `LCASE([$выражение])` - возвращает строку маленьких букв, полученную изменением регистра букв исходной строки `[$выражение]`. Пример:
        /// ```qsp
        /// LCASE('TExT#') & ! 'text#'
        /// ```
        "lcase"
        /// `LEN([$выражение])` - возвращает длину строки [$выражение].
        "len"
        /// `MID([$выражение],[#выражение 1],[#выражение 2])` - вырезает из строки `[$выражение]` строку, которая начинается с символа номер `[#выражение 1]` и имеет длину `[#выражение 2]`. Индексация символов в строке ведётся с 1.
        /// Параметр `[#выражение 2]` может отсутствовать, при этом вырезается вся строка, начиная с символа [#выражение 1]. Примеры:
        /// ```qsp
        /// MID('abcd', 1, 2) равно 'ab'
        /// MID('abcd', 2, 3) равно 'bcd'
        /// MID('abcd', 2) равно 'bcd'
        /// ```
        "mid"
        /// `REPLACE([$выражение 1],[$выражение 2],[$выражение 3])` - заменяет в строке [$выражение 1] все вхождения строки [$выражение 2] строкой [$выражение 3]. Если [$выражение 3] отсутствует или указана пустая строка, то удаляет в исходной строке все вхождения искомой строки. Примеры:
        /// `REPLACE('test', '12', '4')` равно `'test'`
        /// `REPLACE('test', 'e', 's')` равно `'tsst'`
        /// `REPLACE('test', 't', '34')` равно `'34es34'`
        /// `REPLACE('test', 't')` равно `'es'`
        "replace"
        /// `STR([#выражение])` - переводит число (числовое выражение) `[#выражение]` в соответствующую строку. Например,
        /// `PL STR(56)` выведет строку `56`.
        "str"
        /// `TRIM([$выражение])` - удаляет прилегающие пробелы и символы табуляции из `[$выражение]`. Затем возвращает полученную строку. Пример:
        /// `TRIM('     TRIM TEST        ')` равно `'TRIM TEST'`
        "trim"
        /// `UCASE([$выражение])` - возвращает строку больших букв, полученную изменением регистра букв исходной строки `[$выражение]`. Пример:
        /// ```qsp
        /// UCASE('TexT#') & ! -> 'TEXT#'
        /// ```
        "ucase"
        /// `VAL([$выражение])` - переводит строку цифр `[$выражение]` в соответствующее число. Если [$выражение] равно '' (пустая строка) или если оно содержит не-цифры, то возвращается 0.
        "val"
    ]
/// Да-да, всё это — процедуры: они что-то выполняют и никуда не перемещают.
let procedures =
    [
        /// `OPENGAME [$выражение]` - если [$выражение] равно '' (пустая строка) или отсутствует, то вызов окна загрузки состояния игры, иначе загрузка состояния из указанного файла. См. также локацию-обработчик события загрузки игры.
        "opengame"
        /// `CMDCLEAR` или `CMDCLR` - очистка строки ввода.
        "cmdclear"
        /// `CMDCLEAR` или `CMDCLR` - очистка строки ввода.
        "cmdclr"
        /// `SAVEGAME [$выражение]` - если [$выражение] равно '' (пустая строка) или отсутствует, то вызов окна сохранения состояния игры, иначе сохранение состояния в указанный файл. См. также локацию-обработчик события сохранения игры.
        "savegame"
        /// `OPENQST [$выражение]` - открытие и запуск заданного файла игры. При использовании данного оператора, не происходит удаления переменных, удаления предметов инвентаря, очистки дополнительного описания и строки ввода, а также остановки проигрываемых файлов (для этого в начале загружаемой игры можно выполнить "KILLALL & CLS & CLOSE ALL").
        "openqst"
        /// `ADDQST [$выражение]` - из заданного файла игры добавляет все локации, названия которых отсутствуют среди текущих игровых локаций. Загруженные локации полностью эквивалентны локациям из основного файла игры.
        "addqst"
        /// KILLQST - удаляет все локации, добавленные с помощью оператора `ADDQST`
        "killqst"
        /// `DELACT [$название]` или `DEL ACT [$название]` - удаляет действие из списка действий на локации (если такое действие существует). Например:
        /// ```qsp
        /// DELACT 'Идти вперед'
        /// DELACT $SELACT
        /// ```
        "delact"
        /// CLA - очистка списка текущих действий.
        "cla"
        /// `ADDOBJ [$название],[$путь к файлу изображения]` или `ADD OBJ [$название],[$путь к файлу изображения]` - добавление предмета с заданным изображением в рюкзак.
        /// К предметам добавляется новый с названием [$название] и изображением [$путь к файлу изображения].
        ///
        /// Параметр [$путь к файлу изображения] может отсутствовать, при этом предмет добавится без изображения.
        ///
        /// Обратите внимание - для использования одинаковых предметов инвентаря, например денег, патронов и т.п., лучше использовать дополнительную переменную, обозначающую количество этих предметов, чтобы не загромождать инвентарь списком из 137 предметов Рубль / Патрон. Для хранения числа предметов можно использовать массивы, индексируемые через строки:
        ///
        /// ```qsp
        /// OBJECTS['деньги'] = 12
        /// OBJECTS['патроны'] = 137
        /// 'Количество: <<OBJECTS[$getobj(countobj)]>>'
        /// ```
        "addobj"
        /// `DELOBJ [$название]` или `DEL OBJ [$название]` - удаление предмета из рюкзака, если таковой имеется. Также см. локацию-обработчик удаления предмета.
        "delobj"
        /// `KILLOBJ [#выражение]` - удаление предмета, расположенного в заданной позиции. Если параметр [#выражение] не указан, то очистка рюкзака.
        /// Индексация предметов рюкзака ведётся с 1. Также см. локацию-обработчик удаления предмета.
        "killobj"
        /// `UNSELECT` или `UNSEL` - отмена выбора предмета. При выборе играющим какого-либо предмета, он остаётся выделенным. Данная команда снимает выделение.
        "unsel"
        /// `UNSELECT` или `UNSEL` - отмена выбора предмета. При выборе играющим какого-либо предмета, он остаётся выделенным. Данная команда снимает выделение.
        "unselect"
        /// KILLALL - эквивалентен конструкции `KILLVAR & KILLOBJ`.
        "killall"
        /// `KILLVAR [$название массива],[#индекс элемента]` - удаление элемента массива. Если индекс элемента не указан, то очищается весь массив. Если оператор вызван без аргументов, то удаляются все переменные - обычно применяется в начале игры, чтобы при возврате в начальную локацию после неудачного прохождения какого-то этапа игры обнулить все переменные (в противном случае, может оказаться, что запертые двери уже открыты, жена похищена до свадьбы, а Баба-Яга уже отдала кому-то нужный клубочек). Примеры:
        /// ```qsp
        /// KILLVAR
        /// KILLVAR 'a'
        /// KILLVAR 'a',3
        /// ```
        "killvar"
        /// `COPYARR [$массив-приёмник],[$массив-источник]` - копирование содержимого массива в другой массив. Копируются как текстовые, так и числовые значения массива. Размер массива-приёмника при копировании не имеет значения. Примеры:
        /// ```qsp
        /// COPYARR '$a','$b'
        /// COPYARR 'a','b'
        /// COPYARR $arrname1,$arrname2
        /// COPYARR 'a<<$arrname1>>','a<<$arrname2>>'
        /// ```
        "copyarr"
        /// В документации не нашел, но вывел опытно:
        /// `LOC [$выражение]`, если локация с таким выражением существует, то возращает `-1`, в противном случае — `0`
        "loc"
        /// `CLEAR` или `CLR` - очистка окна пользователя.
        "clear"
        /// `CLEAR` или `CLR` - очистка окна пользователя.
        "clr"
        /// `CLOSE [$путь к звуковому файлу]` - остановка проигрывания звукового файла с заданным названием.
        /// `CLOSE ALL` - остановка проигрывания всех активных звуковых файлов.
        "close"
        /// `CLS` - эквивалентен конструкции `CLEAR & *CLEAR & CLA & CMDCLEAR`, т.е. очищает всё, кроме списка предметов.
        "cls"
        /// `DYNAMIC [$строка кода],[параметр 1],[параметр 2], ...` - выполнение кода. Данный оператор позволяет динамически генерировать код игры. Переданные параметры хранятся в массиве `ARGS`. После выполнения кода предыдущие значения `ARGS` восстанавливаются. Примеры:
        /// ```qsp
        /// DYNAMIC '$a="string<<$b>>"'
        /// DYNAMIC '$a'
        /// DYNAMIC 'if $a="string":''text!'''
        /// DYNAMIC "
        /// $args[0]
        /// addobj $args[1]
        /// ",'Текст','Вилка'
        /// ```
        "dynamic"
        /// `MENU [$выражение]` - вызов меню с заданным названием
        "menu"
        /// `MSG [выражение]` - вывод заданного сообщения в информационном окне.
        "msg"
        /// `NL [выражение] - переход на новую строку (перевод каретки), затем вывод текста в окне пользователя. Если [выражение]` не указано, то перевод строки. Отличается от `PL` порядком вывода текста.
        "nl"
        /// `P [выражение]` - вывод текста в окно пользователя (по умолчанию находится справа внизу, обычно служит для вспомогательных целей).
        "p"
        /// `PL [выражение]` - вывод текста, затем переход на новую строку в окне пользователя. Если `[выражение]` не указано, то перевод строки
        "pl"
        /// `PLAY [$путь к звуковому файлу],[#громкость]` - проигрывание звукового файла с заданным названием и громкостью. Громкость указывается в процентах от 0 до 100.
        /// Параметр `[#громкость]` может отсутствовать, при этом громкость принимается равной 100%. Примеры:
        /// `PLAY 'sound/music.mp3'` - проигрывает файл с громкостью 100%
        /// `PLAY 'sound/music.mp3',50` - проигрывает файл в половину возможной громкости
        /// `PLAY 'sound/music.mp3',0` - проигрывает файл с громкостью 0% (без звука)
        /// `PLAY '<<$file>>.mid',volume` - проигрывает файл, имя которого хранится в $file (расширение "mid") с громкостью, значение которой задано в volume
        /// `PLAY $file,volume` - аналогично
        /// Если файл уже проигрывается, то изменяется громкость звучания без его "перезапуска". Поддерживается множество различных аудиоформатов и одновременное звучание до 32-х композиций.
        "play"
        /// обновление интерфейса (а также смена цветов, шрифта, назначенных с помощью системных переменных `BCOLOR`, `FCOLOR`, `LCOLOR`, `FSIZE`, `$FNAME`).
        "refint"
        /// возвращает название выделенного действия.
        "selact"
        /// `SETTIMER [#выражение]` - задает интервал таймера для локации-счётчика (по умолчанию 500мс, т.е. локация-счётчик обрабатывается 2 раза в секунду). Также влияет на частоту автоматического обновления интерфейса.
        "settimer"
        /// `SHOWACTS [#выражение]` - если значение выражения отлично от 0, то показывает список действий, иначе скрывает его. Примеры:
        /// `SHOWACTS 1` - показывает список действий
        /// `SHOWACTS 0` - скрывает список действий
        "showacts"
        /// `SHOWINPUT [#выражение]` - если значение выражения отлично от 0, то показывает строку ввода, иначе скрывает её.
        "showinput"
        /// `SHOWOBJS [#выражение]` - если значение выражения отлично от 0, то показывает список предметов, иначе скрывает его.
        "showobjs"
        /// `SHOWSTAT [#выражение]` - если значение выражения отлично от 0, то показывает дополнительное описание, иначе скрывает его.
        "showstat"
        /// `VIEW [$путь к графическому файлу]` - просмотр картинки из указанного файла. Если вместо [$путь к графическому файлу] указана пустая строка ('') или параметр не указан, то это скроет окно с картинкой.
        "view"
        /// `WAIT [#выражение]` - остановка выполнения программы на заданное количество миллисекунд (1 секунда = 1000 миллисекунд).
        "wait"
    ]

let transferOperators =
    [
        /// `JUMP [$выражение]` - переход в текущем коде (при обработке локации / выбора действия) на метку [$выражение]. Метка на локации обозначается как ":[название метки]". После описания метки (через "&") могут идти операторы. Если интерпретатор находит случайную метку, то он её просто игнорирует. Например:
        /// ```qsp
        /// jump 'КонеЦ'
        /// p 'Это сообщение не будет выведено'
        /// :конец
        /// p 'А это сообщение пользователь увидит'
        /// ```
        /// С помощью оператора `JUMP` можно организовывать циклы:
        /// ```qsp
        /// s = 0
        /// :loop
        /// if s < 9:
        ///     s=s+1
        ///     pl s
        ///     jump 'LOOP'
        /// end
        /// p 'Всё!'
        /// ```
        /// Оператор "JUMP" также полезен во время отладки квеста, чтобы "обойти" группу операторов, которые временно не нужны.
        "jump"
        /// `GOSUB [$выражение],[параметр 1],[параметр 2], ...` или `GS [$выражение],[параметр 1],[параметр 2], ...` - обработка локации с названием [$выражение]. Базовое описание локации добавляется к текущему описанию, базовые действия добавляются к текущим действиям, и происходит выполнение операторов в поле "Выполнить при посещении", затем возврат на исходную строку (продолжение выполнения программы).
        /// Переданные параметры хранятся в массиве `ARGS`. После обработки локации предыдущие значения `ARGS` восстанавливаются. Примеры:
        /// ```qsp
        /// GS 'ход' & ! обработка локации "ход". Массив ARGS пуст.
        /// GS $loc,1 & ! обработка локации, название которой хранится в $loc с передачей одного параметра. ARGS[0] равен 1.
        /// GS 'ход',$var,2,'данные' & ! обработка локации "ход" с передачей 3-х параметров. $ARGS[0] равен значению $var, ARGS[1] равен 2, $ARGS[2] содержит строку "данные".
        /// ```
        "gosub"
        /// См. `GOSUB`
        "gs"
        /// `GOTO [$выражение],[параметр 1],[параметр 2], ...` или `GT [$выражение],[параметр 1],[параметр 2], ...` - переход на локацию с названием [$выражение]. Поле основного описания локации, а также список текущих действий заменяются описанием и действиями новой локации.
        /// Переданные параметры хранятся в массиве ARGS. Примеры:
        /// ```qsp
        /// GT 'локация' & ! переход на локацию "локация". Массив ARGS пуст.
        /// GT 'локация',1,'данные' & ! переход на локацию "локация" с передачей 2-х параметров. ARGS[0] равен 1, $ARGS[1] содержит строку "данные".
        /// ```
        "goto"
        /// см. `GOTO`
        "gt"
        /// `XGOTO [$выражение],[параметр 1],[параметр 2], ...` или `XGT [$выражение],[параметр 1],[параметр 2], ...` - отличается от "GOTO / GT" тем, что при переходе не очищается поле основного описания локации, а базовое описание новой локации добавляется к текущему основному описанию. Тем не менее, список действий заменяется действиями новой локации.
        "xgoto"
        /// См. `XGOTO`
        "xgt"
    ]
let unknown =
    [
        "freelib"
        "inclib"
        "dellib"
        "addlib"
    ]
let binaryOperators =
    [
        // Для значения "верно" настоятельно рекомендуется использовать -1.
        /// `[#выражение 1] AND [#выражение 2]` - операция "и". Если оба рядом стоящие выражения верны, то верно и всё выражение.
        "and"
        /// `[#выражение 1] OR [#выражение 2]` - операция "или". Если хотя бы одно из рядом стоящих выражений верно, то верно и всё выражение.
        "or"
        /// `[#выражение 1] MOD [#выражение 2]` - операция вычисления остатка от деления.
        "mod"
        /// `NO [#выражение]` - отрицание. Верно, если `[#выражение]` ложно и наоборот (аналогично "NOT" в Basic).
        "no"
        /// `OBJ [$выражение]` - верно, если в рюкзаке есть предмет `[$выражение]`.
        "obj"
    ]
let keywords =
    [
        /// `ACT [$название],[$путь к файлу изображения]:[оператор] & [оператор] & ...` - добавление действия к существующим на локации.
        /// К действиям добавляется новое с описанием [$название] и изображением [$путь к файлу изображения]. При нажатии на него выполнятся заданные операторы.
        /// Параметр [$путь к файлу изображения] может отсутствовать, при этом действие добавится без изображения.
        /// Также см. раздел "Многострочные IF / ACT".
        "act"
        "if"
        "else"
        "elseif"
        "end"
        /// `SET [название переменной]=[выражение]`, `LET [название переменной]=[выражение]` или `[название переменной]=[выражение]` - установка значения переменной. Если нужно установить текстовое значение переменной, то перед её названием ставится `$`.
        /// Примеры:
        /// ```qsp
        /// SET A=123
        /// SET $B='строка'
        /// LET C=A
        /// D=456
        /// $D='ещё строка'
        /// $D='и ещё
        ///        одна
        /// строка'
        /// ```
        "set"
        /// См. `set`
        "let"
        /// завершение выполнения текущего кода (преждевременный выход из подпрограммы / обработчика какого-либо события...).
        "exit"
    ]
