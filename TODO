# Задания

## feat(cli)!: wrap exists command in `search` subcommand

Сейчас программа работает так:

Пользователь задаёт папку (там можно и отдельный файл, только в CLI оно не выведено).

К примеру:

```bash
qsp-toolbox <!-- todo -->
```

Программа:

* перебирает рекурсивно во всех подпапках файлы `*.qsp` или `*.gam`
* декомпилирует бинарники с помощью `gam2txt` (если нету в той же папке уже исходника с таким же именем или не стоит флаг <!-- todo -->)
* прогоняет исходник через парсер и записывает ошибки в отдельный файл `output.log` (почему нельзя было сразу писать в консоль — загадка)

И всё, прям вообще всё.

Я это всё использовал на каталоге игр, чтобы проверить парсер. Если в `output.log` была ошибка в какой-то игре, то я открывал исходники в редакторе с расширением и смотрел, что ж там такое. В основном ошибки были связаны с `end`'ами. Серьёзно, это прям бич всего Куспа. Возникает он из-за банального незнания, как форматировать код.

А ещё у меня там реализованы какие-то зачатки поиска по образцу (в CLI сейчас, опять-таки, не выведено), но я не я не пойму, как оно работает.

По-идеи, можно было прям в консоль написать statement (или несколько?). Этот код парсится, а потом сопоставляется с кодом исходника QSP. Если образец находится, то выводится номер строки, где оно было найдено. Пока всё сырое и непонятное.

Сейчас главное — обернуть всю эту махину в `search`, а когда-нибудь потом до всего этого доберусь.

## feat(cli): add `lint` subcommand

Если команда `search` должна искать код по образцу, то команда `lint` должна выявлять ошибки в коде.

По сути она работает точно так же, как и расширение, т.е. парсит код и попутно выявляет следующие ошибки:

* синтаксические ошибки (от чего сам парсер падает и не хочет парсить дальнейший код)
* вызов неизвестных процедур
* вызов неизвестных функций
* лишний `end`
* и т.д.

Программа должна писать всё это в консоль согласно следующему шаблону:

```
относительный/путь/к/игра.qsps(100, 10)
Лишний end:

код
```

Или что-то такое. Для вдохновения можно глянуть на ESLint или ещё куда.

Разрабатывать команду нужно по остаточному принципу: сперва сделать линт в `Core`, потом добавить ее в `ServerLanguage`, а уже затем добавлять в `Cli`.

Я так хочу, потому что расширение удобнее как по мне и нагляднее. Линт все равно нужно как-то отлаживать, а лучшей отладки чем через VS Code не придумаешь. С другой стороны, приоритет идёт на миграцию игр на новую версию Куспа, и желательно весь каталог Куспа так перебрать. Поэтому команде быть.

## Прочие

* Спросить у Байта насчёт `obj add 'Зелье'`: оно выглядит как statement, но но при этом не подчиняется синтаксису: `proc arg1, arg2, ...`

Синтаксис:
    ☐ Вызов процедуры `The(Lady), 'or', the, Tiger`. Сейчас такое `*p(Lady), 'or', the, Tiger` работает
    ☐ Сделать полноценный HTML-parser
    ☐ Если конструкция `if`/`act` обрывается на завершении локации, то можно так и сказать, а не расписывать полотно с ожидаемыми инструкциями
    ☐ Парсить лишние `)`, но помечать их как ошибки
    ☐ Как-то нужно определять, что конструкция `for` разрешена или нет
    ☐ `gs 'loc', , 1` — пропуск аргумента. В QSP 5.7.0 под Windows не работает, но работает в Quest Navigator, кажется.

Статический анализ:
    ☐ Удаление предмета, который нигде не добавляется
    ☐ Переменная присваивается, но ни разу не используется (заданные переменные — исключение)
    ☐ Переменная используется, но ни разу не присваивается (заданные переменные — исключение)
    ☐ Инструкции после `exit`, `jump` и прочих операторов перехода не сработают
    ☐ `a = 'foo'`, `#a = 'foo'`, `a[expr] = 'foo'`, `#a[expr] = 'foo'`

Highlight:
    ☐ Label highlight in `func('label')` or `$func('label')`

Форматирование:
    ☐ `stmt & ! comment`
