Синтаксис:
    ✔ Однострочный `else` @done(20-07-06 20:37)
    ☐ `_` в выражениях
    ☐ `if x = 10: ! comment`
    ☐ Вызов процедуры `The(Lady), 'or', the, Tiger`. Сейчас такое `*p(Lady), 'or', the, Tiger` работает
    ✔ Допускать на уровне синтаксиса неопределенные процедуры со звездочкой (например, `*proc`), а уже на уровне семантики запрещать @done
    ☐ Лишний `end`
    ✔ Бардак с комментариями @done(20-07-10 08:09)
    ☐ Разобраться, почему parser всё еще допускает `proc call someAnotherStatement`, хотя изначально нужен `&`: `proc call & someAnotherStatement`. Явно что-то упустил, да и код станет понятнее, если инструкции как-то явно разбивать.
    ✔ В строках есть подстановка (например, `'<<expr>>'`) @done(20-07-09 23:00)
    ✔ Строковые значения в подстановке `'<<''str''>>'` и `"<<""x"">>"`, соответственно. Эх, ну зачем так делать? Можно же без экранизация обойтись, что ж вы за люди такие? Можно же так `'<<'str'>>'` распарсить. Можно было бы сказать, что мы просто хотим использовать воспользоваться выражением `'<<' + 'str'`, так и здесь выбьет ошибку: мол, непарное количество скобок. Ладно, ничего не поделаешь — придется делать.
    ☐ Полноценный HTML-parser
    ✔ Эх, а еще есть `<a href="exec:`. В этом мире слишком много зла. Хотя бы эту штуку придется сделать, если хочется полностью схватить все вызовы локаций.
Подсказки:
    ✔ Ключевые слова
    ✔ Функции
    ✔ Процедуры
    ☐ @low Бинарные операторы
Семантика:
    ☐ А ведь переменные `args` и `$curloc` для каждой локации локальны, значит, пришло время строить что-то более серьезное с областью видимости переменных.
    ✔ Вызов несуществующей функции/процедуры
    ✔ Переопределение процедур/функций
    ✔ Количество аргументов к процедурам @done(20-07-09 01:09)
    ✔ Количество аргументов к функциям @done(20-07-09 11:11)
    ☐ Переменная присваивается, но ни разу не используется (заданные переменные — исключение)
    ☐ Переменная используется, но ни разу не присваивается (заданные переменные — исключение)
    Явные ошибки присваивания:
        ☐ `a = 'foo'`, `#a = 'foo'`, `a[expr] = 'foo'`, `#a[expr] = 'foo'`
    ✔ Признавать `cla` и прочие процедуры без аргументов как процедуры, а не переменные, как это происходит сейчас @done(20-07-09 13:58)
    ☐ `add obj $someobj` — что делать с этим безобразием? Синтаксически это — вызов процедуры `add` с выражением `obj $someobj`, которое возвращает 0, если предмета `$someobj` нет в инвентаре, как заявлено в документации префиксного оператора `obj`. Однако документация говорит, что выражение `add obj [$выражение]` воспринимается как `addobj [$выражение]`. Какого лешего? Это контринтуитивно и глупо. `close all` — туда же вместе с `del act` и `del obj`
    ✔ `MSG('content')` @done(20-07-09 13:58)
Highlight:
    ✔ Комментарий все еще не разбивает токены на несколько `Range` @done(20-07-06 11:29)
    ✔ Однотонный цвет комментария @done
    ☐ @low бинарные операторы
    ✔ Variable highlight @done(20-07-09 20:22)
    ✔ Label highlight
    ☐ Jump label highlight
Форматирование:
    ☐ `stmt & ! comment`
    ✔ Убрать пробел после вызова процедуры без аргументов, например, `*pl ` @done(20-07-09 14:08)
    ✔ Разбивать строки, если они разделены `\n` (сделать выборочно)
    ✔ `$str = {}` превращает в: @done(20-07-10 10:26)
      ```qsp
      $str = {

      }
      ```
☐ Работа с проектом, то есть не просто с одним файлом, а с целым множеством.
